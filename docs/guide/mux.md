# 多路复用 (Multiplexing)

`gonc` 引入了基于 `smux`/`yamux` 的多路复用协议，允许在一个物理 TCP/KCP 连接中承载无数个虚拟的逻辑流。

---

## 🆚 核心原理对比

为了理解 `-mux` 的作用，我们以访问 HTTP 文件服务器为例，对比两种模式的区别。

### 1. 传统模式 (无 Mux)

如果不使用 Mux，当浏览器访问 `gonc` 搭建的 HTTP 服务时，浏览器的每一个并发请求（下载 HTML、CSS、JS、图片）都会触发一个新的 TCP 连接。

* **命令**：
    * 服务端：`gonc -e ":httpserver ." -k -l 2222`
    * 客户端：(浏览器直接访问) `http://server-ip:2222`

**缺点**：

1. **重复握手**：每个文件传输前都要进行 3 次握手（如果是 TLS 则是 3+4 次），延迟巨大。
2. **资源占用**：服务端需要频繁处理 Accept 和 Close，产生大量 `TIME_WAIT` 状态。

---

### 2. -mux 多路复用模式

使用 `-mux` 后，`gonc` 客户端与服务端之间只建立 **一条** 长效的物理连接（隧道）。客户端模式的gonc需要用`-mux-l`指定隧道的本地入口端口，之后浏览器访问本地端口发出的成百上千个请求，都被封装成轻量级的“流 (Stream)”，在这条隧道里并发传输。

* **命令**：
* 服务端：`gonc -e ":httpserver ." -mux ...`
* 客户端：`gonc -mux-l 8080 ...`

后续访问本机 `http://127.0.0.1:8080/`, 将直接在隧道内创建流。

---

## 🚀 快速上手

我们将搭建一个加密的 HTTP 文件服务器，并通过 Mux 隧道在本地访问。

<div class="interactive-box">
  <label>🛠️设置示例server-ip:</label>
  <input type="text" placeholder="server-ip" value="server-ip" oninput="updateServerIP(this)">
</div>

### 1. 服务端 (Server)

在服务器端开启监听，启用 TLS 加密和 Mux 协议封装。

```bash
# -e ":httpserver ." : 内置 HTTP 服务，共享当前目录
# -mux               : 启用多路复用协议层
gonc -e ":httpserver ." -tls -psk mysecret123 -k -l 2222 -mux

```

### 2. 客户端 (Client)

在本地连接服务器，并开启一个本地监听端口 (`-mux-l`)，将流量导入 Mux 隧道。

```bash
# -mux-l 8080 : 在本地监听 8080，所有进入该端口的流量都将被复用到隧道中
gonc server-ip 2222 -tls -psk mysecret123 -mux-l 8080

```

### 3. 浏览器访问

现在，打开你本地的浏览器，访问：

`http://127.0.0.1:8080`

你看到的页面内容实际上来自远程服务器，但所有的资源加载请求都通过那**唯一的一条 TCP 连接**高效安全的传输。

---

## ⚙️ 参数详解

| 参数 | 说明 |
| --- | --- |
| **`-mux`** | **启用多路复用 (被动端/服务端)**。告诉 `gonc` 在建立一个会话（TCP或KCP）后，进入 Mux 模式，等待虚拟的逻辑流的建立，再将每个虚拟的逻辑流交给上层服务（如 `-e` 指定的模块）处理。 |
| **`-mux-l <port>`** | **本地 Mux 监听器 (主动端/客户端)**。建立连接后，在本地开启一个 TCP 监听端口。当有应用连接该端口时，`gonc` 会在现有的 Mux 隧道中打开一个新的虚拟的逻辑流。参数值为`-`时，可以不监听端口，直接将控制台的stdio作为逻辑流。 |
| **`-mux-engine <string>`** | **选择底层引擎**。默认为 `smux`。可选值：• `yamux`: 另一个开源的mux引擎。 |

!!! tip "引擎兼容性"
客户端和服务端必须使用相同的 `-mux-engine`，否则会导致协议握手失败。默认都是 `smux`，无需手动指定。

!!! tip "mux模式冲突"
你不能在启用 `-mux` `-mux-l <port>` 参数的mux模式下，再使用 :mux 模块。

---

## 🧠 进阶场景：作为反向代理隧道

利用 `-mux`，你可以轻松将内网服务暴露出来。

**场景**：内网服务器 A 有一个 Redis (6379)，想通过公网机器 B 访问它。

1. **内网机器 A (服务端)**：
将流量转发给 Redis，并封装在 Mux 里。
```bash
# :nc 转发到 localhost:6379
gonc -e ":nc 127.0.0.1 6379" -mux -tls -psk mysecret123 -l 443

```


2. **公网机器 B (客户端)**：
连接 A，并在本地开启 16379 提供服务。
```bash
# 任何连接 B:16379 的请求，都会通过隧道瞬间到达 A 的 Redis
gonc server-ip 443 -tls -psk mysecret123 -mux-l 0.0.0.0:16379

```
